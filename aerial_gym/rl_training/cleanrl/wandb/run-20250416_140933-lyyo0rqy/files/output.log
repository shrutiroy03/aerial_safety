[37m[8008 ms][base_task] - INFO : Setting seed: 4291932095 (base_task.py:38)
[37m[8009 ms][reach_avoid_task] - INFO : Building environment for reach-avoid task. (reach_avoid_task.py:44)
[37m[8009 ms][reach_avoid_task] - INFO : Sim Name: base_sim, Env Name: env_with_obstacles, Robot Name: lmf2, Controller Name: lmf2_velocity_control (reach_avoid_task.py:45)
[37m[8009 ms][env_manager] - INFO : Populating environments. (env_manager.py:73)
[37m[8009 ms][env_manager] - INFO : Creating simulation instance. (env_manager.py:87)
[37m[8009 ms][env_manager] - INFO : Instantiating IGE object. (env_manager.py:88)
[37m[8009 ms][IsaacGymEnvManager] - INFO : Creating Isaac Gym Environment (IGE_env_manager.py:41)
[37m[8009 ms][IsaacGymEnvManager] - INFO : Acquiring gym object (IGE_env_manager.py:73)
[37m[8010 ms][IsaacGymEnvManager] - INFO : Acquired gym object (IGE_env_manager.py:75)
[37m[8011 ms][IsaacGymEnvManager] - INFO : Fixing devices (IGE_env_manager.py:89)
[37m[8011 ms][IsaacGymEnvManager] - INFO : Using GPU pipeline for simulation. (IGE_env_manager.py:102)
[37m[8011 ms][IsaacGymEnvManager] - INFO : Sim Device type: cuda, Sim Device ID: 0 (IGE_env_manager.py:105)
[31m[8011 ms][IsaacGymEnvManager] - CRITICAL : 
[31m Setting graphics device to -1.
[31m This is done because the simulation is run in headless mode and no Isaac Gym cameras are used.
[31m No need to worry. The simulation and warp rendering will work as expected. (IGE_env_manager.py:112)
[37m[8011 ms][IsaacGymEnvManager] - INFO : Graphics Device ID: -1 (IGE_env_manager.py:119)
[37m[8011 ms][IsaacGymEnvManager] - INFO : Creating Isaac Gym Simulation Object (IGE_env_manager.py:120)
[33m[8011 ms][IsaacGymEnvManager] - WARNING : If you have set the CUDA_VISIBLE_DEVICES environment variable, please ensure that you set it
[33mto a particular one that works for your system to use the viewer or Isaac Gym cameras.
[33mIf you want to run parallel simulations on multiple GPUs with camera sensors,
[33mplease disable Isaac Gym and use warp (by setting use_warp=True), set the viewer to headless. (IGE_env_manager.py:127)
[33m[8011 ms][IsaacGymEnvManager] - WARNING : If you see a segfault in the next lines, it is because of the discrepancy between the CUDA device and the graphics device.
[33mPlease ensure that the CUDA device and the graphics device are the same. (IGE_env_manager.py:132)
[37m[9118 ms][IsaacGymEnvManager] - INFO : Created Isaac Gym Simulation Object (IGE_env_manager.py:136)
[37m[9119 ms][IsaacGymEnvManager] - INFO : Created Isaac Gym Environment (IGE_env_manager.py:43)
[37m[9246 ms][env_manager] - INFO : IGE object instantiated. (env_manager.py:109)
[37m[9246 ms][env_manager] - INFO : Creating warp environment. (env_manager.py:112)
[37m[9246 ms][env_manager] - INFO : Warp environment created. (env_manager.py:114)
[37m[9246 ms][env_manager] - INFO : Creating robot manager. (env_manager.py:118)
[37m[9246 ms][BaseRobot] - INFO : [DONE] Initializing controller (base_robot.py:26)
[37m[9247 ms][BaseRobot] - INFO : Initializing controller lmf2_velocity_control (base_robot.py:29)
[33m[9247 ms][base_multirotor] - WARNING : Creating 128 multirotors. (base_multirotor.py:32)
[37m[9247 ms][env_manager] - INFO : [DONE] Creating robot manager. (env_manager.py:123)
[37m[9247 ms][env_manager] - INFO : [DONE] Creating simulation instance. (env_manager.py:125)
[37m[9247 ms][asset_loader] - INFO : Loading asset: model.urdf for the first time. Next use of this asset will be via the asset buffer. (asset_loader.py:71)
[37m[9248 ms][asset_loader] - INFO : Loading asset: panel.urdf for the first time. Next use of this asset will be via the asset buffer. (asset_loader.py:71)
[37m[9252 ms][asset_loader] - INFO : Loading asset: 1_x_1_wall.urdf for the first time. Next use of this asset will be via the asset buffer. (asset_loader.py:71)
[37m[9254 ms][asset_loader] - INFO : Loading asset: 0_5_x_0_5_wall.urdf for the first time. Next use of this asset will be via the asset buffer. (asset_loader.py:71)
[37m[9256 ms][asset_loader] - INFO : Loading asset: small_cube.urdf for the first time. Next use of this asset will be via the asset buffer. (asset_loader.py:71)
[37m[9257 ms][asset_loader] - INFO : Loading asset: left_wall.urdf for the first time. Next use of this asset will be via the asset buffer. (asset_loader.py:71)
[37m[9261 ms][asset_loader] - INFO : Loading asset: right_wall.urdf for the first time. Next use of this asset will be via the asset buffer. (asset_loader.py:71)
[37m[9263 ms][asset_loader] - INFO : Loading asset: back_wall.urdf for the first time. Next use of this asset will be via the asset buffer. (asset_loader.py:71)
[37m[9264 ms][asset_loader] - INFO : Loading asset: front_wall.urdf for the first time. Next use of this asset will be via the asset buffer. (asset_loader.py:71)
[37m[9267 ms][asset_loader] - INFO : Loading asset: bottom_wall.urdf for the first time. Next use of this asset will be via the asset buffer. (asset_loader.py:71)
[37m[9269 ms][asset_loader] - INFO : Loading asset: top_wall.urdf for the first time. Next use of this asset will be via the asset buffer. (asset_loader.py:71)
[37m[9271 ms][asset_loader] - INFO : Loading asset: cuboidal_rod.urdf for the first time. Next use of this asset will be via the asset buffer. (asset_loader.py:71)
[37m[9289 ms][env_manager] - INFO : Populating environment 0 (env_manager.py:179)
[33m[9602 ms][robot_manager] - WARNING : 
[33mRobot mass: 1.2400000467896461,
[33mInertia: tensor([[0.0134, 0.0000, 0.0000],
[33m        [0.0000, 0.0144, 0.0000],
[33m        [0.0000, 0.0000, 0.0138]], device='cuda:0'),
[33mRobot COM: tensor([[0., 0., 0., 1.]], device='cuda:0') (robot_manager.py:427)
[33m[9602 ms][robot_manager] - WARNING : Calculated robot mass and inertia for this robot. This code assumes that your robot is the same across environments. (robot_manager.py:430)
[31m[9602 ms][robot_manager] - CRITICAL : If your robot differs across environments you need to perform this computation for each different robot here. (robot_manager.py:433)
using device: cuda:0
[isaacgym:gymutil.py] Unknown args:  ['--task=reach_avoid_task', '--track', '--wandb-project-name=safe-rl', '--wandb-entity=shrutiroy03-princeton-university']
Not connected to PVD
+++ Using GPU PhysX
Physics Engine: PhysX
Physics Device: cuda:0
GPU Pipeline: enabled
*** Can't create empty tensor
WARNING: allocation matrix is not full rank. Rank: 4
creating render graph
Module warp.utils load on device 'cuda:0' took 1.52 ms
Module aerial_gym.sensors.warp.warp_kernels.warp_camera_kernels load on device 'cuda:0' took 10.49 ms
Module aerial_gym.sensors.warp.warp_kernels.warp_stereo_camera_kernels load on device 'cuda:0' took 14.62 ms
Module aerial_gym.sensors.warp.warp_kernels.warp_lidar_kernels load on device 'cuda:0' took 7.37 ms
finishing capture of render graph
Encoder network initialized.
Defined encoder.
[ImgDecoder] Starting create_model
[ImgDecoder] Done with create_model
Defined decoder.
Loading weights from file:  /home/shruti/workspaces/aerial_gym_ws/src/aerial_gym_simulator/aerial_gym/utils/vae/weights/ICRA_test_set_more_sim_data_kld_beta_3_LD_64_epoch_49.pth
num actions:  4
num obs:  81
[37m[10041 ms][env_manager] - INFO : [DONE] Populating environments. (env_manager.py:75)
[33m[10061 ms][IsaacGymEnvManager] - WARNING : Headless: True (IGE_env_manager.py:424)
[37m[10062 ms][IsaacGymEnvManager] - INFO : Headless mode. Viewer not created. (IGE_env_manager.py:434)
[33m[10241 ms][asset_manager] - WARNING : Number of obstacles to be kept in the environment: 9 (asset_manager.py:32)
/home/shruti/workspaces/aerial_gym_ws/src/aerial_gym_simulator/aerial_gym/control/motor_model.py:45: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  torch.tensor(self.min_thrust, device=self.device, dtype=torch.float32).expand(
/home/shruti/workspaces/aerial_gym_ws/src/aerial_gym_simulator/aerial_gym/control/motor_model.py:48: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  torch.tensor(self.max_thrust, device=self.device, dtype=torch.float32).expand(
[33m[10531 ms][control_allocation] - WARNING : Control allocation does not account for actuator limits. This leads to suboptimal allocation (control_allocation.py:48)
[37m[10533 ms][WarpSensor] - INFO : Camera sensor initialized (warp_sensor.py:50)
/home/shruti/workspaces/aerial_gym_ws/src/aerial_gym_simulator/aerial_gym/utils/vae/vae_image_encoder.py:29: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = clean_state_dict(torch.load(weight_file_path))
sac_continuous_action.py:571: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  actions[step] = torch.tensor(action, dtype=torch.float32, device=device)
Traceback (most recent call last):
  File "sac_continuous_action.py", line 574, in <module>
    next_obs, rewards[step], next_done, info = envs.step(action)
  File "sac_continuous_action.py", line 288, in step
    observations, rewards, terminations, truncations, infos = super().step(action)
  File "/home/shruti/miniconda3/envs/safe-rl/lib/python3.8/site-packages/gym/core.py", line 280, in step
    return self.env.step(action)
  File "/home/shruti/workspaces/aerial_gym_ws/src/aerial_gym_simulator/aerial_gym/task/reach_avoid_task/reach_avoid_task.py", line 307, in step
    self.rewards[:], self.safety_margin[:], self.terminations[:] = self.compute_rewards_and_crashes(self.obs_dict)
  File "/home/shruti/workspaces/aerial_gym_ws/src/aerial_gym_simulator/aerial_gym/task/reach_avoid_task/reach_avoid_task.py", line 408, in compute_rewards_and_crashes
    return compute_reward(
RuntimeError: The following operation failed in the TorchScript interpreter.
Traceback of TorchScript (most recent call last):
  File "/home/shruti/workspaces/aerial_gym_ws/src/aerial_gym_simulator/aerial_gym/task/reach_avoid_task/reach_avoid_task.py", line 456, in compute_reward
                                   parameter_dict["angvel_max"] - torch.abs(angular_velocity[:, 1]),
                                   parameter_dict["angvel_max"] - torch.abs(angular_velocity[:, 2]),
                                   parameter_dict["angle_max"] - torch.abs(euler_angles[:, 0]),
                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~ <--- HERE
                                   parameter_dict["angle_max"] - torch.abs(euler_angles[:, 1]),
                                   parameter_dict["obs_dist_lmin"] - torch.amin(image_obs, [1,2]),
RuntimeError: KeyError: angle_max
Traceback (most recent call last):
  File "sac_continuous_action.py", line 574, in <module>
    next_obs, rewards[step], next_done, info = envs.step(action)
  File "sac_continuous_action.py", line 288, in step
    observations, rewards, terminations, truncations, infos = super().step(action)
  File "/home/shruti/miniconda3/envs/safe-rl/lib/python3.8/site-packages/gym/core.py", line 280, in step
    return self.env.step(action)
  File "/home/shruti/workspaces/aerial_gym_ws/src/aerial_gym_simulator/aerial_gym/task/reach_avoid_task/reach_avoid_task.py", line 307, in step
    self.rewards[:], self.safety_margin[:], self.terminations[:] = self.compute_rewards_and_crashes(self.obs_dict)
  File "/home/shruti/workspaces/aerial_gym_ws/src/aerial_gym_simulator/aerial_gym/task/reach_avoid_task/reach_avoid_task.py", line 408, in compute_rewards_and_crashes
    return compute_reward(
RuntimeError: The following operation failed in the TorchScript interpreter.
Traceback of TorchScript (most recent call last):
  File "/home/shruti/workspaces/aerial_gym_ws/src/aerial_gym_simulator/aerial_gym/task/reach_avoid_task/reach_avoid_task.py", line 456, in compute_reward
                                   parameter_dict["angvel_max"] - torch.abs(angular_velocity[:, 1]),
                                   parameter_dict["angvel_max"] - torch.abs(angular_velocity[:, 2]),
                                   parameter_dict["angle_max"] - torch.abs(euler_angles[:, 0]),
                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~ <--- HERE
                                   parameter_dict["angle_max"] - torch.abs(euler_angles[:, 1]),
                                   parameter_dict["obs_dist_lmin"] - torch.amin(image_obs, [1,2]),
RuntimeError: KeyError: angle_max